//  Copyright (c) 2022, Zhengliang Liu
//  All rights reserved

/**
* @file geometry_info_stl.cpp
* @author Zhengliang Liu
* @brief functions for geometries reprensented by STL points
* @date  2022-5-25
* @note .
*/
#ifndef  DEBUG_DISABLE_3D_FUNCTIONS
#include "auxiliary_inline_func.h"
#include "io/log_write.h"
#include "criterion/geometry_info_connection.h"
#include "grid/sfbitset_aux.h"
namespace rootproject {
namespace amrproject {
namespace criterion {
/**
* @brief   function to set indices and size of vectors in GeometryCoordinate to
*          store real and int variable
* @note
*/
void GeometryInfoConnection3D::SetIndex() {
    if (bool_vec_velocities_) {
        k0UxIndex_ = 0; k0UyIndex_ = k0UxIndex_ + 1;
        k0UzIndex_ = k0UyIndex_ + 1;
        k0NumRealForEachPoint_ = k0UzIndex_;
    }
    if (bool_vec_forces_) {
        k0FxIndex_ = k0UzIndex_ + 1; k0FyIndex_ = k0FxIndex_ + 1;
        k0FzIndex_ = k0FyIndex_ + 1;
        k0NumRealForEachPoint_ = k0FzIndex_;
    }

    geo_point_info_instance_.vec_real.resize(k0NumRealForEachPoint_);
}

/**
* @brief   function to initialize status of geometries
* @return  0 successful, 1 geometry is undefined
* @note
*/
int GeometryInfoConnection3D::InitialGeometry(
    std::shared_ptr<GeometryInfoInterface> ptr_geo) {
    DefUint dims = 3;
    SetIndex();
    switch (k0DefaultGeoShapeType_) {
    case DefaultGeoShapeType::kCircle:
        DefaultGeoShapeManager::GetInstance()
            ->geo_circle_initial(dims, ptr_geo);
        return 0;
    default:
        return 1;
    }
}
int GeometryInfoConnection3D::UpdateGeometry(
    std::shared_ptr<GeometryInfoInterface> ptr_geo) {

}
/**
* @brief   function to create map_connection_given_level_ from geometry points 
*          and connection information.
* @note
*/
void GeometryInfoConnection3D::InitialConnectionGivenLevel() {
    for (auto iter_connection :vec_connection_raltion_) {
        for (DefSizet i = 0; i < iter_connection.size(); ++i) {
            DefSFBitset geo_sfbitset;
            map_connection_given_level_
            for (DefSizet j = 0; j < iter_connection.size(); ++i) {

            }
        }
    }
}
void GeometryInfoConnection3D::DecomposeNHigerLevel(const DefSizet i_level_grid,
    const DefReal decompose_length,
    const std::unordered_map<DefSizet, bool>& map_indices_base,
    std::unordered_map<DefSizet, bool>* const ptr_map_indices_remain){

};
void GeometryInfoConnection3D::DecomposeOneHigerLevel(
    const DefSizet i_level, const DefReal decompose_length) {
    DefUint icount = 0, imax = 3;
    // initialize coordinate and connection at current level
    // those at the lower level
    DefSizet vec_size = vec_coordinate_each_level_.size();
    DefSizet level_diff = i_level - i_level_;
    if (vec_size == level_diff) {
        if (i_level - 1 == i_level_) {
            vec_coordinate_each_level_.emplace_back(
                vec_coordinate_origin_);
            map_connection_higher_level_.emplace_back(
                map_connection_given_level_);
        } else {
            vec_coordinate_each_level_.emplace_back(
                vec_coordinate_each_level_.at(level_diff - 1));
            map_connection_higher_level_.emplace_back(
                map_connection_higher_level_.at(level_diff - 1));

        }
    } else if (vec_size < i_level - i_level_) {
        io::LogWarning("Information at one level lower does not exist "
            "for decompose geometry in function"
            " GeometryInfoConnection::DecomposeOneHigerLevel.");
    }
    // initialize indices of segment will be decomposed
    std::unordered_map<DefSizet, std::vector<DefSizet>> map_index_base;
    DefSizet num_lines;
    for (const auto& iter : map_connection_higher_level_.at(level_diff)) {
        num_lines = iter.second.size();
        std::vector<DefSizet> vec_2nd_points(num_lines);
        for (DefSizet i = 0; i < num_lines; ++i) {
            vec_2nd_points.at(i) = i;
        }
        map_index_base.insert({ iter.first, vec_2nd_points });
    }

    // splitng utill length of each segament is less than the targeted one
    while (!map_index_base.empty()&& icount < imax) {
        ++icount;
        std::cout << map_index_base.size()  << " " << level_diff << "ss" << std::endl;
        std::unordered_map<DefSizet, std::vector<DefSizet>>
            map_index_remain;
        DecomposeOnce(decompose_length, map_index_base,
            &vec_coordinate_each_level_.at(level_diff),
            &map_connection_higher_level_.at(level_diff),
            &map_index_remain);
        //for (const auto& iter : map_connection_higher_level_.at(level_diff)) {
        //    for (const auto& iter_vec : iter.second) {
        //        std::cout << iter.first << " " << iter_vec.index_second << satd
        //    }
      
        //}
        map_index_base.swap(map_index_remain);
    }
    if (icount >= imax) {
        io::LogWarning("Procedure of decomposing geometry exceed"
            "the the limit of iteration.");
    }
}
/**
* @brief   function to add point between two linked vertices
* @param[in] decompose_length  targeted length less than
*            which a midpoint will be added
* @param[in] map_indices_base  indices of linked vertices
* @param[out] ptr_vec_coordi coordinates of existing and added vertices
* @param[out] ptr_vec_connect connection of existing and added vertices
* @param[out] ptr_map_indices_remain indices of linked vertices whose length
*                                    is greater than the targeted one
* @note
*/
void GeometryInfoConnection::DecomposeOnce(const DefReal decompose_length,
    const std::unordered_map<DefSizet, std::vector<DefSizet>>&
    map_indices_base,
    std::vector<GeometryCoordinate>* const ptr_vec_coordi,
    std::unordered_map<DefSizet, std::vector<GeometryConnectIndex>>*
    const ptr_map_connect,
    std::unordered_map<DefSizet, std::vector<DefSizet>>*
    const ptr_map_indices_remain) {
    io::LogWarning("The function GeometryInfoConnection::DecomposeOnce is emptty, "
        "using derive class instead.");
}
/**
* @brief   function to add point between two linked vertices
* @param[in] decompose_length  targeted length less than
*            which a midpoint will be added
* @param[in] map_indices_base  indices of linked vertices
* @param[out] ptr_vec_coordi coordinates of existing and added vertices
* @param[out] ptr_vec_connect connection of existing and added vertices
* @param[out] ptr_map_indices_remain indices of linked vertices whose length
*                                    is greater than the targeted one
* @note
*/
void GeometryInfoConnect2DLine::DecomposeOnce(const DefReal decompose_length,
    const std::unordered_map<DefSizet, std::vector<DefSizet>>&
    map_indices_base,
    std::vector<GeometryCoordinate>* const ptr_vec_coordi,
    std::unordered_map<DefSizet, std::vector<GeometryConnectIndex>>*
    const ptr_map_connect,
    std::unordered_map<DefSizet, std::vector<DefSizet>>*
    const ptr_map_indices_remain) {

    // add coordinates and connections at a level higher
    GeometryCoordinate coordinate_temp;
    coordinate_temp.coordinate = { 0,0 };
    GeometryConnectIndex connect_temp;
    DefReal decompose_threshold = decompose_length * decompose_factor_;
    DefSizet index_second, coordi_max, connect_max;
    DefReal x_start, x_end, y_start, y_end, distance;
    for (const auto& index_1st_point : map_indices_base) {
        x_start = ptr_vec_coordi->at(index_1st_point.first).coordinate[kXIndex];
        y_start = ptr_vec_coordi->at(index_1st_point.first).coordinate[kYIndex];
        for (const auto index_2nd_point : index_1st_point.second) {
            if (!ptr_map_connect->at(index_1st_point.first).
                at(index_2nd_point).bool_decomposed) {
                index_second = ptr_map_connect->
                    at(index_1st_point.first).at(index_2nd_point).index_second;
                x_end = ptr_vec_coordi->at(index_second).coordinate[kXIndex];
                y_end = ptr_vec_coordi->at(index_second).coordinate[kYIndex];
                distance = std::sqrt(Square(x_start - x_end)
                    + Square(y_start - y_end));
                if (distance > decompose_threshold) {
                    // add a new point
                    coordinate_temp.coordinate[kXIndex] = (x_start + x_end) / 2;
                    coordinate_temp.coordinate[kYIndex] = (y_start + y_end) / 2;
                    ptr_vec_coordi->emplace_back(coordinate_temp);
                    // update connection information
                    coordi_max = ptr_vec_coordi->size() - 1;
                    ptr_map_connect->at(index_1st_point.first).
                        at(index_2nd_point).index_second = coordi_max;
                    connect_temp.index_second = coordi_max;
                    if (ptr_map_connect->find(index_second) != ptr_map_connect->end()) {
                        ptr_map_connect->at(index_second).emplace_back(connect_temp);
                    } else {
                        ptr_map_connect->insert({ index_second, {connect_temp} });
                    }
                    connect_max = ptr_map_connect->at(index_second).size() - 1;
                    if (distance / 2. > decompose_threshold + kEps) {
                        ptr_map_connect->at(index_1st_point.first).
                            at(index_2nd_point).bool_decomposed = false;
                        ptr_map_connect->at(index_second).
                            at(connect_max).bool_decomposed = false;
                        if (ptr_map_indices_remain->find(index_1st_point.first)
                            == ptr_map_indices_remain->end()) {
                            ptr_map_indices_remain->insert(
                                { index_1st_point.first , {index_2nd_point} });
                        } else {
                            ptr_map_indices_remain->at(index_1st_point.first).
                                emplace_back(index_2nd_point);
                        }
                        if (ptr_map_indices_remain->find(coordi_max)
                            == ptr_map_indices_remain->end()) {
                            ptr_map_indices_remain->insert(
                                { index_second , {connect_max} });
                        } else {
                            ptr_map_indices_remain->at(index_second).
                                emplace_back(connect_max);
                        }
                    }
                    else {
                        ptr_map_connect->at(index_1st_point.first).
                            at(index_2nd_point).bool_decomposed = true;
                        ptr_map_connect->at(index_second).
                            at(connect_max).bool_decomposed = true;
                    }
                }
            }
        }
    }
}
}  // end namespace criterion
}  // end namespace amrproject
}  // end namespace rootproject
